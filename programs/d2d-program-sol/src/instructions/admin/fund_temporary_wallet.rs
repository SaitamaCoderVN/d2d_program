use crate::errors::ErrorCode;
use crate::events::TemporaryWalletFunded;
use crate::states::{DeployRequest, DeployRequestStatus, TreasuryPool};
use anchor_lang::prelude::*;

/// Fund a temporary wallet for deployment
/// Only backend admin can call this instruction
/// 
/// Policy: Prefer Reward Pool for operational deploys, Admin Pool for special Ops
/// This allows Reward Pool to be used for deployments while maintaining separation
#[derive(Accounts)]
#[instruction(request_id: [u8; 32], amount: u64, use_admin_pool: bool)]
pub struct FundTemporaryWallet<'info> {
    #[account(
        mut,
        seeds = [TreasuryPool::PREFIX_SEED],
        bump = treasury_pool.bump
    )]
    pub treasury_pool: Account<'info, TreasuryPool>,

    #[account(
        mut,
        seeds = [DeployRequest::PREFIX_SEED, request_id.as_ref()],
        bump = deploy_request.bump,
        constraint = deploy_request.status == DeployRequestStatus::PendingDeployment @ ErrorCode::InvalidDeploymentStatus
    )]
    pub deploy_request: Account<'info, DeployRequest>,

    #[account(
        mut,
        constraint = admin.key() == treasury_pool.admin @ ErrorCode::Unauthorized
    )]
    pub admin: Signer<'info>,

    /// CHECK: Treasury Pool PDA (holds deposits, source of liquid_balance)
    #[account(
        mut,
        seeds = [TreasuryPool::PREFIX_SEED],
        bump = treasury_pool.bump
    )]
    pub treasury_pda: UncheckedAccount<'info>,

    /// CHECK: Temporary wallet generated by backend
    #[account(mut)]
    pub temporary_wallet: UncheckedAccount<'info>,
}

/// Fund temporary wallet for deployment
/// 
/// Flow:
/// 1. Check TreasuryPool.liquid_balance >= deployment_cost
/// 2. Transfer from Treasury Pool PDA -> temporary wallet (via lamport mutation)
/// 3. Update liquid_balance in TreasuryPool state
/// 
/// NOTE: Funds sourced from TreasuryPool.liquid_balance (NOT RewardPool or PlatformPool)
/// RewardPool is used exclusively for paying rewards to backers
/// PlatformPool is used exclusively for admin operations (0.1% developer fees)
pub fn fund_temporary_wallet(
    ctx: Context<FundTemporaryWallet>,
    _request_id: [u8; 32],
    amount: u64,
    _use_admin_pool: bool, // Unused: always uses TreasuryPool.liquid_balance
) -> Result<()> {
    let treasury_pool = &mut ctx.accounts.treasury_pool;
    let deploy_request = &mut ctx.accounts.deploy_request;

    require!(!treasury_pool.emergency_pause, ErrorCode::ProgramPaused);
    require!(amount > 0, ErrorCode::InvalidAmount);

    // Verify that the requested amount matches the deployment cost in deploy_request
    require!(
        amount == deploy_request.deployment_cost,
        ErrorCode::InvalidAmount
    );

    // IMPORTANT: Use liquid_balance from Treasury PDA (not from pools)
    // This ensures withdrawals work correctly when funds are used for deployments
    require!(
        treasury_pool.liquid_balance >= amount,
        ErrorCode::InsufficientLiquidBalance
    );

    let treasury_pda_info = ctx.accounts.treasury_pda.to_account_info();
    let temporary_wallet_info = ctx.accounts.temporary_wallet.to_account_info();

    // Verify Treasury PDA has enough lamports
    require!(
        treasury_pda_info.lamports() >= amount,
        ErrorCode::InsufficientTreasuryFunds
    );

    // Transfer SOL from Treasury PDA -> temporary wallet via lamport mutation
    // CRITICAL: Use lamport mutation for program-owned accounts (not CPI System transfer)
    {
        let mut treasury_lamports = treasury_pda_info.try_borrow_mut_lamports()?;
        let mut temporary_lamports = temporary_wallet_info.try_borrow_mut_lamports()?;

        let new_treasury_balance = (**treasury_lamports)
            .checked_sub(amount)
            .ok_or(ErrorCode::CalculationOverflow)?;
        let new_temporary_balance = (**temporary_lamports)
            .checked_add(amount)
            .ok_or(ErrorCode::CalculationOverflow)?;

        **treasury_lamports = new_treasury_balance;
        **temporary_lamports = new_temporary_balance;
    }

    // Update treasury pool state
    // IMPORTANT: Deduct from liquid_balance (not total_deposited)
    // This allows withdrawals to work correctly
    treasury_pool.liquid_balance = treasury_pool
        .liquid_balance
        .checked_sub(amount)
        .ok_or(ErrorCode::CalculationOverflow)?;

    // Store temporary wallet address and borrowed amount in deploy_request
    deploy_request.ephemeral_key = Some(temporary_wallet_info.key());
    deploy_request.borrowed_amount = amount; // Track borrowed amount for fee calculation (1% monthly)

    emit!(TemporaryWalletFunded {
        request_id: deploy_request.request_id,
        temporary_wallet: temporary_wallet_info.key(),
        amount,
        funded_at: Clock::get()?.unix_timestamp,
    });

    Ok(())
}
